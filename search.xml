<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[垃圾评论检测方法研究综述]]></title>
      <url>http://yoursite.com/2017/12/05/%E5%9E%83%E5%9C%BE%E8%AF%84%E8%AE%BA%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-任务介绍"><a href="#1-任务介绍" class="headerlink" title="1.任务介绍"></a>1.任务介绍</h2><p>随着互联网的普及，电子商务飞速发展。而在电子商务中，商品的评论直接影响用户对商品的印象进而影响销量。在利益的驱动下部分商家和个人为了快速提高自身产品的竞争能力或者打击竞争对手的商品，通过刷单服务获取大量好评和销售量。同时投机者使用电子商务平台较大的点击量发布恶意信息，如广告信息、垃圾网络链接以及黄赌毒信息，产生大量垃圾评论。垃圾评论已经严重影响电子商务平台交易的公平性和用户的切身利益。如何保证用户评论信息的真实性和客观性以及如何检测类似的欺诈行为成为当前研究的一个热点，同时高质量的评论分析也是商品评论挖掘和情感分析的一个重要预处理步骤。本篇文章探讨了垃圾评论领域经典方法以及深度学习催生的新方法，并对比它们的效果。</p>
<p>垃圾评论主要分为两类，第一类是内容型垃圾评论，即在评论内容中发布广告、评论内容与主题相关性低和在评论内容中发布黄赌毒信息等；第二类为欺诈性评论，即评论发布者通过作弊手段达到提升信誉度、增加销售量的目的。如电商平台中的刷单服务就是典型的欺诈行为。</p>
<a id="more"></a> 
<h2 id="2-典型方法"><a href="#2-典型方法" class="headerlink" title="2.典型方法"></a>2.典型方法</h2><p>垃圾评论特征主要来源于三种：评论内容、评论者以及被评论的商品。典型的垃圾评论检测方法分为利用评论文法信息、行为信息建模、以及数据统计建模三大类。在每一大类中又有很多具体的方法，以下对这些方法展开讨论和性能比较。</p>
<h3 id="2-1-词法分析"><a href="#2-1-词法分析" class="headerlink" title="2.1 词法分析"></a>2.1 词法分析</h3><p>对句子中的词进行词法分析建立稀疏语法树，从而获得更深层的语法特征。</p>
<p><img src="./images/stylometry.png" alt=""></p>
<p>采用线性分类器，5-fold交叉验证，主要采取了Lexical、Shallow syntax、Deep syntax等特征，具体特征值根据TF-IDF算法进行计算。根据论文[]中提供的结果，在数据集 Tripadvisor、Essay、Yelp上的结果分别如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature Set</th>
<th style="text-align:center">TripAd visor</th>
<th style="text-align:center">Essay</th>
<th style="text-align:center">Yelp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Words</td>
<td style="text-align:center">88.4</td>
<td style="text-align:center">77.0</td>
<td style="text-align:center">59.9</td>
</tr>
<tr>
<td style="text-align:center">Shallow Syntax</td>
<td style="text-align:center">87.4</td>
<td style="text-align:center">80.0</td>
<td style="text-align:center">62.0</td>
</tr>
<tr>
<td style="text-align:center">Deep Syntax</td>
<td style="text-align:center">90.4</td>
<td style="text-align:center">78.0</td>
<td style="text-align:center">63.5</td>
</tr>
<tr>
<td style="text-align:center">Deep Syntax + Words</td>
<td style="text-align:center">91.2</td>
<td style="text-align:center">85.0</td>
<td style="text-align:center">64.3</td>
</tr>
</tbody>
</table>
<p>提升了3-8%的准确率。</p>
<h3 id="2-2-建模行为信息"><a href="#2-2-建模行为信息" class="headerlink" title="2.2 建模行为信息"></a>2.2 建模行为信息</h3><p>基于语言信息的模型很好，但是缺乏对撒谎行为上的捕捉、判别垃圾信号时容错性差、评论者非常容易逃脱规则。</p>
<h4 id="2-2-1-检测异常评论行为"><a href="#2-2-1-检测异常评论行为" class="headerlink" title="2.2.1 检测异常评论行为"></a>2.2.1 检测异常评论行为</h4><p>垃圾评论者一般对所评论的商品有一定目标性，倾向于评论一类相似的产品，在论文[]中，定义了$E_{ij}$为用户$i$向用户$j$的评论。图标中呈现的是评论者——商品对的数量，一些评论者对同一件商品进行了多次评论，因此以目标商品为驱动的异常评论行为是存在的。</p>
<p><img src="./images/target.png" alt=""></p>
<p>评论者对购物网站中产品的评论、评分、购买以及用户之间的交流行为都体现了其特定目的，通过对购物网站中评论者的行为特征分析，假设产品垃圾评论者存在以下 5 种行为模式：(1)同一用户对同一产品发表多个评论或多次评分的行为模式。(2)同一用户对同一产品组的不同产品发表多个评论或多次评分的行为模式。(3)用户评分与平均评分偏差较大的行为模式。(4)其他用户对某用户发表的评论回应较少的行为模式。(5)一个用户对产品的购买次数远小于评论次数的行为模式。根据用户的不同行为模式，针对用户进行建模，每个模型都采用打分的方法来衡量用户为垃圾评论者的可能性，得分越高为垃圾评论者的可能性就越大。关于五种行为的详细建模过程参考论文《基于用户行为的产品垃圾评论者检测研究》（邱云飞等）。</p>
<p>实验结果：<br><img src="./images/spamicity.png" alt=""></p>
<p>总体来说，实验的结果显示了本文方法在检测垃圾评论者与非垃圾评论者方面与手工标记垃圾评论者是大致相同的，尤其是目标产品组的方法更好地代表了用户的垃圾评论者的特征行为。</p>
<h4 id="2-2-2-群体行为分析"><a href="#2-2-2-群体行为分析" class="headerlink" title="2.2.2 群体行为分析"></a>2.2.2 群体行为分析</h4><p>垃圾评论发布团体检测比垃圾评论发布者检测多一个用户团体的划分过程，通过聚类方式对评论进行用户团体划分，然后通过分析用户团体的异常行为检测欺诈型评论。</p>
<h4 id="2-2-3-基于图关系的方法"><a href="#2-2-3-基于图关系的方法" class="headerlink" title="2.2.3 基于图关系的方法"></a>2.2.3 基于图关系的方法</h4><p>将评论者和评论连接，将评论与产品连接形成图，形成评论关系图。分别定义评论者可信度、评论真实度、商量可靠度等指标进行衡量。详细算法参考论文[Fei et al. ICWSM 2013]</p>
<p><img src="./images/store.png" alt=""></p>
<h4 id="2-2-4-基于分布的方法"><a href="#2-2-4-基于分布的方法" class="headerlink" title="2.2.4 基于分布的方法"></a>2.2.4 基于分布的方法</h4><p>基于分布的方法主要是通过分析评论的时间分布、地域分布等信息检测垃圾评论。根据分布信息提取特征主要有以下几种：</p>
<ol>
<li>检测评论爆发；用马尔科夫随机场对评论发布信息建模[Fei et al.<br>ICWSM 2013]。</li>
<li>在时域层面分析评论。分析垃圾评论和非垃圾评论发布时间的分布。</li>
<li>分析IP和Cookie信息。</li>
<li>地理信息。</li>
</ol>
<p>根据文法信息提取特征和根据行为信息提取特征，实验对比：</p>
<p><img src="./spam_images/comparison.png" alt=""></p>
<h3 id="2-3-统计建模"><a href="#2-3-统计建模" class="headerlink" title="2.3 统计建模"></a>2.3 统计建模</h3><h4 id="2-3-1-矩阵分解"><a href="#2-3-1-矩阵分解" class="headerlink" title="2.3.1 矩阵分解"></a>2.3.1 矩阵分解</h4><p>构建参数表达评论者和评论两者之间的关系以及两者的属性之间的关系，例如是否浏览过、打分记录等等参数，将特征组合在一起构成特征向量。将多组向量放在一起形成评论者和评论的关系矩阵，对关系矩阵进行张量分解[ Nickel et al. 2011]，从而得到映射到另一个空间，得到隐层特征。</p>
<p><img src="./images/tensor_fac.png" alt=""></p>
<h2 id="3-深度学习方法"><a href="#3-深度学习方法" class="headerlink" title="3. 深度学习方法"></a>3. 深度学习方法</h2><p>深度学习方法如卷积神经网络（CNN）和循环神经网络被广泛用于图像识别、自然语言处理等多个模式识别领域，在论文《Deceptive Opinion Spam Detection Using Neural Network》中，作者设计了CNN和RNN融合的深度学习模型，模型结构如下图：</p>
<p><img src="./images/rnn_cnn.png" alt=""></p>
<p>论文中采用Word Embedding提取特征，实验结果如下：</p>
<p><img src="./images/cnn_res.png" alt=""></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本篇文章对垃圾评论检测典型方法与深度学习方法进行了总结，传统的评论文法分析、用户行为分析、矩阵分析等方法对垃圾评论检测效果逐步提升。而近几年来在图像和自然语言处理领域大显身手的卷积神经网络和循环神经网络也提高了垃圾评论检测的准确率处所有方法中领先水平。与传统方法不同的是，深度学习有更好的扩展性，通过改变结构、层数等方式较传统方法更容易获得效果提升。另外不同结构网络（CNN、RNN、DBN等）之间的配合重组有可能产生更好的效果。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p>Leman Akoglu, Rishi Chandy, and Christos Faloutsos. 2013. Opinion Fraud Detection in Online Reviews by Network Effects. In Proceedings of the AAAI International Conference on Web and Social Media.</p>
</li>
<li><p>Shlomo Argamon, Casey Whitelaw, Paul Chase, Sobhan Raj Hota, Navendu Garg, and Shlomo Levitan. 2007. Stylistic text classification using functional lexical features. Journal of the American Society for Information Science and Technology, 58(6):802–822.</p>
</li>
<li><p>Avrim Blum and Tom Mitchell. 1998. Combining labeled and unlabeled data with co‐training. In Proceedings of the eleventh annual conference on Computational learning theory, pages 92–100. Jacob Eisenstein, Brendan O’Connor, Noah A. Smith, and Eric P. Xing. 2010. A latent variable model for geographic</p>
</li>
<li><p>lexical variation. Empirical Methods in Natural Language Processing:1277–1287, October. G. Fei, A. Mukherjee, B. Liu, M. Hsu, M. Castellanos, and R. Ghosh. 2013. Exploiting Burstiness in Reviews for Review Spammer Detection. AAAI International Conference on Weblogs and Social Media.</p>
</li>
<li><p>Song Feng, Longfei Xing, Anupam Gogar, and Yejin Choi. 2012. Distributional Footprints of Deceptive Product Reviews. In The International AAAI Conference on Weblogs and Social Media.</p>
</li>
<li><p>Y. Feng, S., Banerjee R., Choi. 2012. Syntactic Stylometry for Deception Detection. In Association for<br>Computational Linguistics.</p>
</li>
<li><p>Donato Hernandez Fusilier, Rafael Guzman Cabrera, Manuel Montes‐y‐Gomez, and Paolo Rosso. 2013. Using PU‐<br>Learning to Detect Deceptive Opinion Spam. ACL Workshop on Computational Approaches to Subjectivity,<br>Sentiment and Social Media Analysis.</p>
</li>
<li><p>Aristides Gionis, Piotr Indyk, and Rajeev Motwani. 1999. imilarity Search in High Dimensions via Hashing.Proceedings of the 25th International Conference on Very Large Data Bases:518–529, September.</p>
</li>
<li><p>Nitin Jindal and Bing Liu. 2007. Review spam detection. In Proceedings of the 16th international conference on World Wide Web ‐ WWW ’07, page 1189, New York, New York, USA, May. ACM Press.</p>
</li>
<li><p>Nitin Jindal and Bing Liu. 2008. Opinion Spam and Analysis. In ACM International Conference on Web Search and Data Mining.</p>
</li>
<li><p>Sangkyum Kim, Hyungsul Kim, Tim Weninger, Jiawei Han, and Hyun Duk Kim. 2011. Authorship classification: a discriminative syntactic tree mining approach. In Proceedings of the 34th international ACM SIGIR conference on Research and development in Information Retrieval, pages 455–464.</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[post]]></title>
      <url>http://yoursite.com/2017/05/14/post/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript递归算法的四种写法]]></title>
      <url>http://yoursite.com/2017/05/11/JavaScript%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p> 转载需提前联系译者，未经允许不得转载。<br>本篇文章为《JavaScript语言精粹》学习笔记。</p>
</blockquote>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><p>《JavaScript语言精粹》函数记忆一章中提到了记忆一节，通过递归的例子说明将中间结果存下来对算法性能的提升，并巧妙利用JavaScript中函数是第一公民、闭包等思想实现了通用的递归，很巧妙，特做笔记以便日后温故而知新。</p>
<a id="more"></a> 
<h1 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h1><p>以递归经典题目fabonacci数列为例，fabonacci数列第一项为0，第二项为1，之后的每项等于前两项之和，因此数列的前几个元素为</p>
<p>$$<br>0,1,1,2,3,5,8,13,\ldots<br>$$</p>
<h1 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h1><p>最普通的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> n&lt;<span class="number">2</span>?n:(fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>));</div><div class="line">&#125;</div><div class="line">fibonacci(<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>这种写法的主要问题在于计算次数，时间复杂度为指数$O(2^n)$</p>
<h1 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h1><p>用一个数组将中间结果存下来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> memo = [<span class="number">0</span>,<span class="number">1</span>];</div><div class="line">  <span class="keyword">var</span> innerf = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> memo[n] != <span class="string">'number'</span>)&#123;</div><div class="line">      memo[n] = innerf(n<span class="number">-1</span>)+innerf(n<span class="number">-2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> innerf(num);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f(<span class="number">4</span>))</div></pre></td></tr></table></figure>
<h1 id="第三种写法"><a href="#第三种写法" class="headerlink" title="第三种写法"></a>第三种写法</h1><p>从递归树最底层向上算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> memo=[<span class="number">0</span>,<span class="number">1</span>];</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">typeof</span> memo[i] != <span class="string">'number'</span>)&#123;</div><div class="line">       memo[i] = memo[i<span class="number">-1</span>]+memo[i<span class="number">-2</span>];</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">  <span class="keyword">return</span> memo[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第四种写法"><a href="#第四种写法" class="headerlink" title="第四种写法"></a>第四种写法</h1><p>封装递归函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memoizer = <span class="function"><span class="keyword">function</span> (<span class="params">memo, formula</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> recur = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> memo[n]!=<span class="string">'number'</span>)&#123;</div><div class="line">      memo[n]=formula(recur,n);      </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> recur;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fabonacci = memoizer([<span class="number">0</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">recur,n</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> recur(n<span class="number">-1</span>)+recur(n<span class="number">-2</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>扩展很简单，求阶乘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = memoizer([<span class="number">1</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">recur,n</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> n*recur(n<span class="number">-1</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flex布局完全教程]]></title>
      <url>http://yoursite.com/2017/03/24/Flex%E5%B8%83%E5%B1%80%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a><br> 作者：<a href="https://css-tricks.com/author/chriscoyier/" target="_blank" rel="external">CHRIS COYIER</a><br> 译者：Shelley Lee<br> 本文同时发布于<a href="https://zhuanlan.zhihu.com/fe-guide" target="_blank" rel="external">知乎专栏：前端指南</a><br> 转载需提前联系译者，未经允许不得转载。</p>
</blockquote>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Flexbox 布局（也叫Flex布局，弹性盒子布局）模块目标在于提供一个更有效地布局、对齐方式，并且能够使父元素在子元素的大小未知或动态变化情况下仍然能够分配好子元素之间的间隙。</p>
<p>Flex布局的主要思想是使父元素能够调节子元素的高度、宽度和排布的顺序，从而能够最好地适应可用布局空间（能够适应不同的设备和不同大小的屏幕）。设定为flex布局的父元素（容器）能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p>
<p>最重要的是，与传统布局中块状元素按照垂直方向摆放，行内元素按照水平方向摆放相比，flex布局是无方向的。传统布局在应对大型复杂的布局时缺乏灵活性，特别是在改变方向、改变大小、伸展、收缩等等方面。</p>
<p><strong>注</strong>: Flex 布局比较适合小规模的布局，Gird布局面向更大规模的布局。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Flex布局是一个完整的模块而不是一个单独的属性，它包括了完整的一套属性。其中有的属性是设置在容器（container，也可以叫做父元素，称为<code>flex container</code>）上，有的则是设置在容器的项目上（item，也可以叫做子元素，称为<code>flex items</code>）上。</p>
<a id="more"></a> 
<p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flex-container.svg" alt=""><br><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flex-items.svg" alt=""></p>
<blockquote>
<p>译者注：由于item译成项目不够直观和形象，以下统一用父元素指代container，子元素指代item。</p>
</blockquote>
<p>如果我们可以说传统布局是建立在块状元素垂直流和行内元素水平流上的，那么flex布局就是建立在”flex-flow方向”上的，通过下图解释flex布局的主要思想。</p>
<p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flexbox.png" alt=""></p>
<p>在flex布局中，子元素要么按照主轴也就是<code>main axis</code>（从<code>main-start</code>到<code>main-end</code>）排布，要么按照交叉轴，也就是<code>cross axis</code>(从<code>cross-start</code>到<code>cross-end</code>)排布。</p>
<p>下面介绍几个概念：</p>
<ul>
<li><strong>main axis</strong>: Flex 父元素的主轴是指子元素布局的主要方向轴，注意主轴不一定是水平的，它由属性<code>flex-direction</code>来确定主轴是水平还是垂直的（后面会介绍）。</li>
<li><strong>main-start|main-end</strong>: 分别表示主轴的开始和结束，子元素在父元素中会沿着主轴从<code>main-start</code>到<code>main-end</code>排布。</li>
<li><strong>main size</strong>: 单个项目占据主轴的长度大小。</li>
<li><strong>cross axis</strong>: 交叉轴，与主轴垂直。</li>
<li><strong>cross-start|cross-end</strong>: 分别表示交叉轴的开始和结束。子元素在交叉轴的排布从<code>cross-start</code>开始到<code>cross-end</code>。</li>
<li><strong>cross size</strong>:  子元素在交叉轴方向上的大小。</li>
</ul>
<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><p>属性分作用于父元素的属性和作用于子元素的属性两部分介绍。</p>
<h3 id="父元素属性"><a href="#父元素属性" class="headerlink" title="父元素属性"></a>父元素属性</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>用来定义父元素是一个 flex布局容器。如果设置为<code>flex</code>则父元素为块状元素，设置为<code>inline-flex</code>父元素呈现为行内元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* or inline-flex */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flex-direction2.svg" alt=""></p>
<p><code>flex-direction</code>定义flex布局的主轴方向。flex布局是单方向布局，子元素主要沿着水平行或者垂直列布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>row</code>: 行方向，<code>flex-direction</code>的默认值，在<code>ltr</code>(left to right， 从左到右)排版方式下从左到右排列，在<code>rtl</code>(right to left， 从右到左)排版方式下从右到左排列。</li>
<li><code>row-reverse</code>: 行反方向，在<code>ltr</code>中从右向左，在<code>rtl</code>中从左到右。</li>
<li><code>column</code>: 列方向，与<code>row</code>相似，只是从上到下。</li>
<li><code>column-reverse</code>: 列反方向，与<code>row-reverse</code>相似，只是从下岛上。</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flex-wrap.svg" alt=""></p>
<p>默认情况下，flex布局中父元素会把子元素尽可能地排在同一行，通过设置<code>flex-wrap</code>来决定是否允许子元素这行排列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span>&#123;</div><div class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>nowrap</code>: 不折行，默认值，所有的子元素会排在一行。</li>
<li><code>wrap</code>: 折行，子元素会从上到下根据需求折成多行。</li>
<li><code>wrap-reverse</code>: 从下向上折行，子元素会从下岛上根据需求折成多行。</li>
</ul>
<p>这里有一些可视化的<a href="https://css-tricks.com/almanac/properties/f/flex-wrap/" target="_blank" rel="external">示例</a>。</p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>属性的缩写形式。默认值是<code>row,nowrap</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</div></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/justify-content.svg" alt=""></p>
<p><code>justify-content</code>属性定义了子元素沿主轴方向的对齐方式，用来当子元素大小最大的时候，分配主轴上的剩余空间。也可以当子元素超出主轴的时候用来控制子元素的对齐方式。</p>
<ul>
<li><code>flex-start</code>: 默认值，朝主轴开始的方向对齐。</li>
<li><code>flex-end</code>: 朝主轴结束的方向对齐。</li>
<li><code>center</code>: 沿主轴方向居中。</li>
<li><code>space-between</code>: 沿主轴两端对齐，第一个子元素在主轴起点，最后一个子元素在主轴终点。</li>
<li><code>space-around</code>: 沿主轴子元素之间均匀分布。要注意的是子元素看起来间隙是不均匀的，第一个子元素和最后一个子元素离父元素的边缘有一个单位的间隙，但两个子元素之间有两个单位的间隙，因为每个子元素的两侧都有一个单位的间隙。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/align-items.svg" alt=""></p>
<p><code>align-items</code>定义了子元素在交叉轴方向的对齐方向，这是在每个子元素仍然在其原来所在行的基础上所说的。可以看作是交叉轴上的<code>justify-content</code>属性;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex-start: 按照交叉轴的起点对齐。</li>
<li>flex-end: 按照交叉轴的终点对齐。</li>
<li>center: 沿交叉轴方向居中。</li>
<li>baseline: 按照项目的第一行文字的基线对齐。</li>
<li>stretch: 默认值，在满足子项目所设置的<code>min-height</code>、<code>max-height</code>、<code>height</code>的情况下拉伸子元素使之填充整个父元素。</li>
</ul>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/align-content.svg" alt=""></p>
<p><code>align-content</code>是当父元素所包含的行在交叉轴方向有空余部分时如何分配空间。与<code>justify-content</code>在主轴上如何对单个子元素对齐很相似。</p>
<p><strong>注意</strong>：当只有一行的时候，该属性并不起作用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>译者注</strong>：该属性中的六个属性值与<code>justify-content</code>中的六个属性意思相似，不同之处在于<code>justify-content</code>沿主轴方向的作用于单个子元素，而<code>align-content</code>沿交叉轴方向作用于行。遂不再赘述各属性值含义。</p>
<p><strong>译者注</strong>：注意<code>align-items</code>和<code>align-content</code>的区别，前者是指在单行内的子元素对齐方式，后者是指多行之间的对齐方式。</p>
</blockquote>
<h4 id="父元素属性总结"><a href="#父元素属性总结" class="headerlink" title="父元素属性总结"></a>父元素属性总结</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">display: flex|inline-flex;</div><div class="line">flex-direction: row | row-reverse | column | column-reverse;</div><div class="line">flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;;</div><div class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</div><div class="line">align-items: flex-start | flex-end | center | baseline | stretch;</div><div class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</div></pre></td></tr></table></figure>
<h3 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/order-2.svg" alt=""></p>
<p>默认情况下，子元素按照代码书写的先后顺序布局，但<code>order</code>属性可以更改子元素出现的顺序。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>译者注</strong>：<code>order</code>的默认值为0;子元素的<code>order</code>值越小，布局越排在前面，参考例图理解。</p>
</blockquote>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/flex-grow.svg" alt=""></p>
<p><code>flex-grow</code>规定在空间允许的情况下，子元素如何按照比例分配可用剩余空间。如果所有的子元素的属性都设定为<code>1</code>，则父元素中的剩余空间会等分给所有子元素。如果其中某个子元素的<code>flex-grow</code>设定为2，则在分配剩余空间时该子元素将获得其他元素二倍的空间（至少会尽力获得）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注</strong>：<code>flex-grow</code>不接受负值。</p>
<blockquote>
<p><strong>译者注</strong>：默认值为<code>0</code>，意味着即使有剩余空间，各子元素也不会放大。</p>
</blockquote>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>与<code>flex-grow</code>属性类似，<code>flex-shrink</code>定义了空间不足时项目的缩小比例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注</strong>： <code>flex-shrink</code>不接受负值。</p>
<blockquote>
<p><strong>译者注</strong>：<code>flex-shrink</code>默认值为<code>1</code>， 当所有子元素都为默认值时，则空间不足时子元素会同比例缩小。如果其中某个子元素的<code>flex-shrink</code>值为0，则空间不足时该子元素并不会缩小。如果其中某个子元素的<code>flex-shrink</code>值为2时，则空间不足时该子元素会以二倍速度缩小。</p>
</blockquote>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><code>flex-basis</code>定义了在计算剩余空间之前子元素默认的大小。可以设置为某个长度（e.g. 20%, 5rem, etc.）或者关键字。关键字<code>auto</code>意味着子元素会按照其本来的大小显示。关键字<code>content</code>意味着根据内容来确定大小——这个关键字到目前没有被很好地支持，所以测试起来比较困难，与<code>content</code>的类似的关键字还有<code>max-content</code>, <code>min-content</code>, <code>fit-content</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果设置为0, 则子元素内容周围的空隙不会根据<code>flex-grow</code>按比例分配，如果设置为<code>auto</code>，则子元素周围额外的空袭会根据<code>flex-grow</code>按照比例分配，如下图：</p>
<p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/rel-vs-abs-flex.svg" alt=""></p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><code>flex</code>是<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>三个属性的缩写。其中第二个和第三个参数(<code>flex-grow</code>,<code>flex-basis</code>)是可选的。默认值为<code>0 1 auto</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推荐使用缩写形式而不是单独地设置每一个属性，缩写形式中会智能地计算出相关值。</p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/align-self.svg" alt=""></p>
<p>通过设置某个子元素的<code>align-self</code>属性，可以覆盖<code>align-items</code>所设置的对齐方式。属性值与<code>align-items</code>中的意义相同，不再赘述。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注</strong>：<code>float</code>,<code>clear</code>和<code>vertical-align</code>对flex子元素没有任何影响。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一：水平垂直居中"><a href="#示例一：水平垂直居中" class="headerlink" title="示例一：水平垂直居中"></a>示例一：水平垂直居中</h3><p>我们从一个非常非常简单的例子开始，解决一个我们经常会遇到的问题：水平垂直居中。如果使用flex布局会非常简单。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">height</span>: <span class="number">300px</span>; <span class="comment">/* 随意设定大小 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.child</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;  <span class="comment">/* 随意设定大小，比父元素要小 */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>; <span class="comment">/* 同上 */</span></div><div class="line">  <span class="attribute">margin</span>: auto;  <span class="comment">/* 见证奇迹的时刻 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个主要原因是，在flex布局的父元素中设置<code>margin</code>为<code>auto</code>会自动吸收额外的空间，所以设置水平垂直的<code>margin</code>都为<code>auto</code>会使子元素在水平垂直方向上都完美居中。</p>
<h3 id="示例二：响应式初体验"><a href="#示例二：响应式初体验" class="headerlink" title="示例二：响应式初体验"></a>示例二：响应式初体验</h3><p>现在我们考虑用更多的属性。考虑有6个子元素，有固定的大小，但是我们希望他们能够在改变浏览器宽度的时候仍然可以在水平轴上完美地显示（注意在不使用媒体查询的前提下）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="comment">/* 首先我们先创建一个flex布局上下文 */</span></div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  </div><div class="line">  <span class="comment">/* 然后我们定义flex方向和是否允许子元素换行</span></div><div class="line">   * 注意这与以下代码等价：</div><div class="line">   * flex-direction: row;</div><div class="line">   * flex-wrap: wrap;</div><div class="line">   */</div><div class="line">  <span class="attribute">flex-flow</span>: row wrap;</div><div class="line">  </div><div class="line">  <span class="comment">/* 然后我们定义在剩余空间上子元素如何排布 */</span></div><div class="line">  <span class="attribute">justify-content</span>: space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成。剩下的就是一些其他样式如颜色的设置了。</p>
<iframe src="https://codepen.io/css-tricks/embed/EKEYob?height=409&theme-id=1&slug-hash=EKEYob&default-tab=result&user=css-tricks#0" style="height:300px;width:100%;overflow:hidden" seamless></iframe>

<p>改变浏览器大小，看看布局会有什么变化吧！</p>
<h3 id="示例三：响应式导航栏"><a href="#示例三：响应式导航栏" class="headerlink" title="示例三：响应式导航栏"></a>示例三：响应式导航栏</h3><p>让我们再尝试一些别的东西。假设我们有一个向右对齐的导航栏在我们网页的最上端，但是我们希望它在中屏上显示时为居中，在小屏上显示为单列。同样使用flex布局，实现起来会很简单。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 大屏 */</span></div><div class="line"><span class="selector-class">.navigation</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex-flow</span>: row wrap;</div><div class="line">  <span class="comment">/* 这里设置对齐主轴方向的末端 */</span></div><div class="line">  <span class="attribute">justify-content</span>: flex-end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 中屏 */</span></div><div class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">800px</span>) &#123;</div><div class="line">  <span class="selector-class">.navigation</span> &#123;</div><div class="line">    <span class="comment">/* 当在中屏上，设置居中，并设置剩余空间环绕在子元素左右 */</span></div><div class="line">    <span class="attribute">justify-content</span>: space-around;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 小屏 */</span></div><div class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">500px</span>) &#123;</div><div class="line">  <span class="selector-class">.navigation</span> &#123;</div><div class="line">    <span class="comment">/* 在小屏上，我们不在使用行作为主轴，而以列为主轴 */</span></div><div class="line">    <span class="attribute">flex-direction</span>: column;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<iframe src="https://codepen.io/css-tricks/embed/YqaKYR?height=283&theme-id=1&slug-hash=YqaKYR&default-tab=result&user=css-tricks#0" style="height:300px;width:100%;overflow:hidden" seamless></iframe>

<p>改变浏览器大小，看看布局会有什么变化吧！</p>
<h3 id="示例四：移动优先的三栏布局"><a href="#示例四：移动优先的三栏布局" class="headerlink" title="示例四：移动优先的三栏布局"></a>示例四：移动优先的三栏布局</h3><p>我们通过灵活使用flex布局尝试一些更好玩的布局。来做一个移动优先的3列布局并带有全屏宽的header和footer。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex-flow</span>: row wrap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 我们要告诉所有的子元素宽度 100% */</span></div><div class="line"><span class="selector-class">.header</span>, <span class="selector-class">.main</span>, <span class="selector-class">.nav</span>, <span class="selector-class">.aside</span>, <span class="selector-class">.footer</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 移动优先依赖于源代码默认的渲染顺序</span></div><div class="line"> * in this case:</div><div class="line"> * 1. header</div><div class="line"> * 2. nav</div><div class="line"> * 3. main</div><div class="line"> * 4. aside</div><div class="line"> * 5. footer</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/* 中屏 */</span></div><div class="line">@<span class="keyword">media</span> all and (min-width: <span class="number">600px</span>) &#123;</div><div class="line">  <span class="comment">/* 我们要告诉两边的sidebar共享一个行 */</span></div><div class="line">  <span class="selector-class">.aside</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span> auto; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 大屏幕 */</span></div><div class="line">@<span class="keyword">media</span> all and (min-width: <span class="number">800px</span>) &#123;</div><div class="line">  <span class="comment">/* 通过order设定各个面板的渲染顺序</span></div><div class="line">   * 告诉主要面板元素占用侧栏两倍的空间</div><div class="line">   */</div><div class="line">  <span class="selector-class">.main</span> &#123; <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">0px</span>; &#125;</div><div class="line">  </div><div class="line">  <span class="selector-class">.aside-1</span> &#123; <span class="attribute">order</span>: <span class="number">1</span>; &#125;</div><div class="line">  <span class="selector-class">.main</span>    &#123; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</div><div class="line">  <span class="selector-class">.aside-2</span> &#123; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</div><div class="line">  <span class="selector-class">.footer</span>  &#123; <span class="attribute">order</span>: <span class="number">4</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<iframe src="https://codepen.io/css-tricks/embed/jqzNZq?height=359&theme-id=1&slug-hash=jqzNZq&default-tab=result&user=css-tricks#0" style="height:300px;width:100%;overflow:hidden" seamless></iframe>

<p>改变浏览器大小，看看布局会有什么变化吧！</p>
<h2 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h2><p>Flex布局需要一些浏览器前缀来最大力度地兼容大多数的浏览器。Flex布局的前缀不只是在属性前面添加浏览器前缀，不同浏览器下的属性名和属性值都不同，这是因为Flexbox布局的标准一直在变，一共有old, tweener, new 三个版本。</p>
<p>可能处理前缀的最好方法是使用新的语法书写CSS并通过<a href="https://css-tricks.com/autoprefixer/" target="_blank" rel="external">Autoprefixer</a>运行CSS，能够很好地处理这个问题。</p>
<p>另外，这里有一个Sass中 @mixin 来处理一些前缀，也可以给你一些处理前缀的启发：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@mixin flexbox() &#123;</div><div class="line">  display: -webkit-box;</div><div class="line">  display: -moz-box;</div><div class="line">  display: -ms-flexbox;</div><div class="line">  display: -webkit-flex;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin flex($values) &#123;</div><div class="line">  -webkit-box-flex: $values;</div><div class="line">  -moz-box-flex:  $values;</div><div class="line">  -webkit-flex:  $values;</div><div class="line">  -ms-flex:  $values;</div><div class="line">  flex:  $values;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin order($val) &#123;</div><div class="line">  -webkit-box-ordinal-group: $val;  </div><div class="line">  -moz-box-ordinal-group: $val;     </div><div class="line">  -ms-flex-order: $val;     </div><div class="line">  -webkit-order: $val;  </div><div class="line">  order: $val;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.wrapper &#123;</div><div class="line">  @include flexbox();</div><div class="line">&#125;</div><div class="line"></div><div class="line">.item &#123;</div><div class="line">  @include flex(1 200px);</div><div class="line">  @include order(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul>
<li><a href="http://www.w3.org/TR/css3-flexbox/" target="_blank" rel="external">Flexbox in the CSS specifications</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/CSS/Tutorials/Using_CSS_flexible_boxes" target="_blank" rel="external">Flexbox at MDN</a></li>
<li><a href="http://dev.opera.com/articles/view/flexbox-basics/" target="_blank" rel="external">Flexbox at Opera</a></li>
<li><a href="http://weblog.bocoup.com/dive-into-flexbox/" target="_blank" rel="external">Diving into Flexbox by Bocoup</a></li>
<li><a href="https://css-tricks.com/using-flexbox/" target="_blank" rel="external">Mixing syntaxes for best browser support on CSS-Tricks</a></li>
<li><a href="http://www.alsacreations.com/tuto/lire/1493-css3-flexbox-layout-module.html" target="_blank" rel="external">Flexbox by Raphael Goetter (FR)</a></li>
<li><a href="http://bennettfeely.com/flexplorer/" target="_blank" rel="external">Flexplorer by Bennett Feely</a></li>
</ul>
<h2 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h2><p>我见过的最棒的flexbox bug总结是Philip Walton 和 Greg Whitworth的<a href="https://github.com/philipwalton/flexbugs" target="_blank" rel="external">Flexbugs</a>，是开源的，你可以在上面跟踪动态。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>首先看一下Flex布局的三个版本</p>
<ul>
<li>(new)是指标准中最近的语法(e.g. <code>display:flex;</code>)。</li>
<li>(tweener)是指2011年以后非官方的临时版本(e.g. <code>display:flexbox;</code>)。</li>
<li>(old)是指2009年以后的旧语法(e.g. <code>display:box;</code>)</li>
</ul>
<p><img src="http://ojr0cmiri.bkt.clouddn.com/a-complete-guide-to-flexbox/browser-support.png" alt=""></p>
<p>Blackberry browser 10+ 支持新语法。</p>
<p>更多混合使用语法达到最佳浏览器兼容，可以参考<a href="http://dev.opera.com/articles/view/advanced-cross-browser-flexbox/#fallbacks" target="_blank" rel="external"> this article (CSS-Tricks)](https://css-tricks.com/using-flexbox/)或者this article (DevOpera)</a></p>
<h2 id="译者的话"><a href="#译者的话" class="headerlink" title="译者的话"></a>译者的话</h2><p>网上有不少flex相关教程，但当我看到<a href="https://css-tricks.com/author/chriscoyier/" target="_blank" rel="external">CHRIS COYIER</a>的这篇文章时，不禁被其详尽所震撼，最近也在撰写布局相关的文章，故产生了翻译此文的想法。翻译过程中尽量保持原文原貌，部分地方做了小幅调整以便更加符合中文思维。文中图片均来源于原文。水平有限，如有误漏之处，还请读者不吝赐教。最后希望此文能给读者带去帮助。</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> CSS布局 </tag>
            
            <tag> Flexbox </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS布局十八般武艺都在这里了]]></title>
      <url>http://yoursite.com/2017/01/13/CSS%E5%B8%83%E5%B1%80%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文首发于<a href="https://zhuanlan.zhihu.com/p/25565751" target="_blank" rel="external">知乎专栏：前端指南</a></p>
</blockquote>
<h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><p>布局是CSS中一个重要部分，本文总结了CSS布局中的常用技巧，包括常用的水平居中、垂直居中方法，以及单列布局、多列布局的多种实现方式（包括传统的盒模型布局和比较新的flex布局实现），希望能给需要的小伙伴带来一些帮助。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>常用居中方法<ul>
<li>水平居中</li>
<li>垂直居中</li>
</ul>
</li>
<li>单列布局</li>
<li>二列&amp;三列布局<ul>
<li>float+margin</li>
<li>position+margin</li>
<li>圣杯布局（float+负margin）</li>
<li>双飞翼布局（float+负margin）</li>
<li>flex布局</li>
</ul>
</li>
<li>总结</li>
</ol>
<a id="more"></a> 
<h3 id="1-常用居中方法"><a href="#1-常用居中方法" class="headerlink" title="1.常用居中方法"></a>1.常用居中方法</h3><p>居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。下面进行分析：</p>
<p><strong>行内元素</strong>：对父元素设置<code>text-align:center;</code><br><strong>定宽块状元素</strong>: 设置左右<code>margin</code>值为<code>auto</code>;<br><strong>不定宽块状元素</strong>:  设置子元素为<code>display:inline</code>,然后在父元素上设置<code>text-align:center</code>;<br><strong>通用方案</strong>: flex布局，对父元素设置<code>display:flex;justify-content:center;</code></p>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。</p>
<p><strong>父元素一定，子元素为单行内联文本</strong>：设置父元素的<code>height</code>等于行高<code>line-height</code><br><strong>父元素一定，子元素为多行内联文本</strong>：设置父元素的<code>display:table-cell</code>或<code>inline-block</code>，再设置<code>vertical-align:middle</code>;<br><strong>块状元素</strong>:设置子元素<code>position:fixed（absolute）</code>，然后设置<code>margin:auto</code>;<br><strong>通用方案</strong>: flex布局，给父元素设置<code>{display:flex; align-items:center;}</code>。</p>
<h3 id="2-单列布局"><a href="#2-单列布局" class="headerlink" title="2.单列布局"></a>2.单列布局</h3><p><img src="https://raw.githubusercontent.com/mafengshe-zhihu/zhihu-column/master/2017-03-04-css%E5%B8%83%E5%B1%80%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/images/single-col.png" alt=""><br>特征：定宽、水平居中</p>
<p>常见的单列布局有两种：</p>
<ul>
<li>一种是<code>header</code>、<code>content</code>、<code>footer</code>宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。</li>
<li>一种是<code>header</code>、<code>footer</code>宽度为浏览器宽度，但<code>content</code>以及<code>header</code>和<code>footer</code>里的内容却不会占满浏览器宽度。</li>
</ul>
<p>对于第一种，对<code>header</code>、<code>content</code>、<code>footer</code>统一设置<code>width</code>或<code>max-width</code>，并通过<code>margin:auto</code>实现居中。</p>
<p><strong>DOM文档</strong>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>尾部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>CSS清单</strong>:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.layout</span>&#123;</div><div class="line"><span class="comment">/*   width: 960px; */</span><span class="comment">/*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span></div><div class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第二种，<code>header</code>、<code>footer</code>的内容宽度为100%，但<code>header</code>、<code>footer</code>的内容区以及<code>content</code>统一设置<code>max-width</code>，并通过<code>margin:auto</code>实现居中。</p>
<p><strong>DOM文档</strong>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>尾部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>CSS清单</strong>:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.layout</span>&#123;</div><div class="line"><span class="comment">/*   width: 960px; */</span><span class="comment">/*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span></div><div class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-二列-amp-三列布局"><a href="#3-二列-amp-三列布局" class="headerlink" title="3. 二列&amp;三列布局"></a>3. 二列&amp;三列布局</h3><p><img src="https://raw.githubusercontent.com/mafengshe-zhihu/zhihu-column/master/2017-03-04-css%E5%B8%83%E5%B1%80%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/images/muti-cols.png" alt=""></p>
<p>二列布局的特征是侧栏固定宽度，主栏自适应宽度。<br>三列布局的特征是两侧两列固定宽度，中间列自适应宽度。</p>
<p>之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。</p>
<h4 id="a-float-margin"><a href="#a-float-margin" class="headerlink" title="a. float+margin"></a>a. float+margin</h4><p><strong>原理说明</strong>：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。</p>
<p><strong>DOM文档</strong>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>sub<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>extra<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>布局步骤</strong>:</p>
<ol>
<li>对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。</li>
<li>对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。</li>
</ol>
<p><strong>CSS清单</strong>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sub</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.main</span>&#123;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>; </div><div class="line">    <span class="attribute">margin-right</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>一些说明</strong>:</p>
<p><em>　注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。
</em>　这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。</p>
<p><strong>二列的实现方法</strong></p>
<p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的<code>margin-right</code>值，其他操作相同。反之亦然。</p>
<h4 id="b-position-margin"><a href="#b-position-margin" class="headerlink" title="b. position+margin"></a>b. position+margin</h4><p><strong>原理说明</strong>：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。</p>
<p><strong>DOM文档</strong>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>布局步骤</strong>:</p>
<ol>
<li>对两边侧栏分别设置宽度，设置定位方式为绝对定位。</li>
<li>设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。</li>
<li>对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。</li>
</ol>
<p><strong>CSS清单</strong>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sub</span>, <span class="selector-class">.extra</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>; </div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.sub</span> &#123; </div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span> &#123; </div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.main</span> &#123; </div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>一些说明</strong>:</p>
<ul>
<li>与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。</li>
<li>如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。</li>
</ul>
<p><strong>二列的实现方法</strong></p>
<p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的<code>margin-right</code>值，其他操作相同。反之亦然。</p>
<h4 id="c-圣杯布局-float-负margin-padding-position"><a href="#c-圣杯布局-float-负margin-padding-position" class="headerlink" title="c. 圣杯布局(float + 负margin + padding + position)"></a>c. 圣杯布局(float + 负margin + padding + position)</h4><p><strong>原理说明</strong>：</p>
<p>主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。</p>
<p><strong>DOM文档</strong>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bd"</span>&gt;</span>         </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>布局步骤</strong>:</p>
<ol>
<li>三者都设置向左浮动。</li>
<li>设置main宽度为100%，设置两侧栏的宽度。</li>
<li>设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。</li>
<li>设置main的padding值给左右两个子面板留出空间。</li>
<li>设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。</li>
</ol>
<p><strong>CSS清单</strong>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.main</span> &#123;        </div><div class="line">    <span class="attribute">float</span>: left;       </div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;   </div><div class="line"> &#125;  </div><div class="line"> <span class="selector-class">.sub</span> &#123;       </div><div class="line">    <span class="attribute">float</span>: left;        </div><div class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;        </div><div class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;               </div><div class="line">    <span class="attribute">position</span>: relative;  </div><div class="line">    <span class="attribute">left</span>: -<span class="number">190px</span>;  </div><div class="line">&#125;   </div><div class="line"><span class="selector-class">.extra</span> &#123;        </div><div class="line">    <span class="attribute">float</span>: left;        </div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;        </div><div class="line">    <span class="attribute">margin-left</span>: -<span class="number">230px</span>; </div><div class="line">    <span class="attribute">position</span>: relative; </div><div class="line">    <span class="attribute">right</span>: -<span class="number">230px</span>;  </div><div class="line"> &#125;</div><div class="line"><span class="selector-id">#bd</span> &#123;        </div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">230px</span> <span class="number">0</span> <span class="number">190px</span>;   </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><strong>一些说明</strong></p>
<ul>
<li>DOM元素的书写顺序不得更改。</li>
<li>当面板的<code>main</code>内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置<code>main</code>的<code>min-width</code>属性或使用双飞翼布局避免问题。</li>
</ul>
<p><strong>二列的实现方法</strong></p>
<p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的<code>padding-right</code>值，其他操作相同。反之亦然。</p>
<h4 id="d-双飞翼布局-float-负margin-margin"><a href="#d-双飞翼布局-float-负margin-margin" class="headerlink" title="d. 双飞翼布局(float + 负margin + margin)"></a>d. 双飞翼布局(float + 负margin + margin)</h4><p><strong>原理说明</strong>：</p>
<p>双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在<code>main</code>元素上加了一层div, 并设置<code>margin</code>,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。</p>
<p><strong>DOM文档</strong>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main-wrap"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span>#main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>布局步骤</strong>:</p>
<ol>
<li>三者都设置向左浮动。</li>
<li>设置main-wrap宽度为100%，设置两个侧栏的宽度。</li>
<li>设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。</li>
<li>设置main的margin值给左右两个子面板留出空间。</li>
</ol>
<p><strong>CSS清单</strong>:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.main</span> &#123;        </div><div class="line">    <span class="attribute">float</span>: left;       </div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;   </div><div class="line"> &#125;  </div><div class="line"> <span class="selector-class">.sub</span> &#123;       </div><div class="line">    <span class="attribute">float</span>: left;        </div><div class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;        </div><div class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;   </div><div class="line">&#125;   </div><div class="line"><span class="selector-class">.extra</span> &#123;        </div><div class="line">    <span class="attribute">float</span>: left;        </div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;        </div><div class="line">    <span class="attribute">margin-left</span>: -<span class="number">230px</span>; </div><div class="line"> &#125;</div><div class="line"><span class="selector-class">.main-wrap</span> &#123;    </div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">230px</span> <span class="number">0</span> <span class="number">190px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>一些说明</strong></p>
<ul>
<li>圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。</li>
<li>双飞翼布局不用设置相对布局，以及对应的left和right值。</li>
<li>通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置<code>position: relative; left: 190px;</code>,可以实现sub+extra+main的布局。</li>
</ul>
<p><strong>二列的实现方法</strong></p>
<p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置<code>main-wrap</code>的<code>margin-right</code>值，其他操作相同。反之亦然。</p>
<h4 id="e-flex布局"><a href="#e-flex布局" class="headerlink" title="e. flex布局"></a>e. flex布局</h4><p>如果你还没有学习flex布局，阮一峰老师的两篇博文将会很适合你。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮一峰的博客——flex语法</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">阮一峰的博客——flex布局案例</a></p>
<p>以下是五种布局的flex布局代码：</p>
<p><strong>DOM文档</strong>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout__main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout__main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>左侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout__main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>右侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>第1个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>第2个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout__main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout__main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>第1个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout__aside"</span>&gt;</span>第2个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>CSS清单</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.layout</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.layout__main</span> &#123;</div><div class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.layout__aside</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传统的布局方法基于盒状模型，依赖 <code>display</code>属性 + <code>position</code>属性 + <code>float</code>属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。</p>
<p>flex布局将是CSS布局的趋势，还未正式成为标准的gird布局也异常吸睛，于是知乎上很多刚入门的小伙伴<br>有了疑惑 <a href="https://www.zhihu.com/question/56515074" target="_blank" rel="external">2017年，圣杯和双飞翼布局已经淘汰了，真的？</a>，对于此我个人仍然坚持我的观点<a href="https://www.zhihu.com/question/56515074/answer/149426231" target="_blank" rel="external">2017年，圣杯和双飞翼布局已经淘汰了，真的？ - Shelley Lee 的回答 - 知乎</a>,至少在目前过渡阶段，仍然坚持夯实基础，稳步向前。</p>
<p>本文完。</p>
<p>PS：以后会继续写Flex布局和Grid布局相关文章，欢迎持续关注，也欢迎大家对文章提出建议或意见。</p>
<p><strong>参考链接</strong><br><a href="https://segmentfault.com/a/1190000004648754" target="_blank" rel="external">CSS垂直居中和水平居中</a><br><a href="http://www.tuicool.com/articles/q2a6Znn" target="_blank" rel="external">圣杯布局小结</a><br><a href="http://www.imooc.com/wenda/detail/254035" target="_blank" rel="external">双飞翼布局介绍-始于淘宝UED_慕课猿问</a><br><a href="http://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/" target="_blank" rel="external">我熟知的三种三栏网页宽度自适应布局方法 “ 张鑫旭-鑫空间-鑫生活</a><br><a href="http://www.fscwz.com/2016/03/24/css-basis-layout-summary/" target="_blank" rel="external">常见的几种布局总结</a></p>
<hr>
<h4 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h4><p>本文知识产权归作者及<a href="http://mafengshe.com/" target="_blank" rel="external">码蜂社</a>所有，转载须注明来源。尊重版权是对知识分享最大的支持。</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> CSS布局 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
